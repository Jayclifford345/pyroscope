Folder structure:
├── create_prompt.py
├── folder_structure_and_contents.txt
├── Dockerfile
├── Dockerfile.load-generator
├── docker-compose.yml
├── load-generator.py
└── lib/
    ├── gaming_server.py
    ├── arcade/
    │   └── arcade.py
    ├── puzzle/
    │   └── puzzle.py
    ├── shooter/
    │   └── shooter.py
    └── utility/
        └── utility.py


Detailed file contents:
Directory: new_gaming_project
  File: create_prompt.py
  Content:
import os

def print_tree_structure(f, root_folder, prefix=""):
    entries = os.listdir(root_folder)
    entries = sorted(entries, key=lambda x: os.path.isdir(os.path.join(root_folder, x)))
    entries_count = len(entries)

    for i, entry in enumerate(entries):
        path = os.path.join(root_folder, entry)
        connector = "├── " if i < entries_count - 1 else "└── "

        if os.path.isdir(path):
            f.write(f"{prefix}{connector}{entry}/\n")
            new_prefix = prefix + ("│   " if i < entries_count - 1 else "    ")
            print_tree_structure(f, path, new_prefix)
        else:
            f.write(f"{prefix}{connector}{entry}\n")


def print_structure_and_contents(root_folder):
    output_file = os.path.join(root_folder, "folder_structure_and_contents.txt")

    with open(output_file, 'w') as f:
        f.write("Folder structure:\n")
        print_tree_structure(f, root_folder)
        f.write("\n\nDetailed file contents:\n")

        for root, dirs, files in os.walk(root_folder):
            current_dir = os.path.relpath(root, root_folder)
            if current_dir == ".":
                current_dir = os.path.basename(root_folder)
            f.write(f"Directory: {current_dir}\n")

            for file_name in files:
                file_path = os.path.join(root, file_name)
                f.write(f"  File: {file_name}\n")
                f.write("  Content:\n")
                
                # Open and print the contents of the file
                with open(file_path, 'r') as file:
                    content = file.read()
                    f.write(content + "\n")
                
                f.write("\n")  # Add extra space between files

if __name__ == "__main__":
    root_folder = "/Users/rperry2174/Desktop/projects/pyroscope/examples/language-sdk-instrumentation/python/new_gaming_project"
    print_structure_and_contents(root_folder)


  File: folder_structure_and_contents.txt
  Content:


  File: Dockerfile
  Content:
FROM python:3.9

RUN pip3 install flask pyroscope-io==0.8.5

ENV FLASK_ENV=development
ENV PYTHONUNBUFFERED=1

COPY lib ./lib
CMD [ "python", "lib/gaming_server.py" ]


  File: Dockerfile.load-generator
  Content:
FROM python:3.9

RUN pip3 install requests

COPY load-generator.py ./load-generator.py

ENV PYTHONUNBUFFERED=1

CMD [ "python", "load-generator.py" ]


  File: docker-compose.yml
  Content:
version: '3'
services:
  pyroscope:
    image: grafana/pyroscope
    ports:
      - '4040:4040'

  us-east:
    ports:
      - 5000
    environment:
      - REGION=us-east
    build:
      context: .

  eu-north:
    ports:
      - 5000
    environment:
      - REGION=eu-north
    build:
      context: .

  ap-south:
    ports:
      - 5000
    environment:
      - REGION=ap-south
    build:
      context: .

  load-generator:
    build:
      context: .
      dockerfile: Dockerfile.load-generator


  File: load-generator.py
  Content:
import random
import requests
import time

HOSTS = [
    'us-east',
    'eu-north',
    'ap-south',
]

GAMES = [
    'arcade',
    'shooter',
    'puzzle',
]

if __name__ == "__main__":
    print(f"starting load generator")
    time.sleep(3)
    while True:
        host = HOSTS[random.randint(0, len(HOSTS) - 1)]
        game = GAMES[random.randint(0, len(GAMES) - 1)]
        print(f"requesting {game} from {host}")
        try:
            resp = requests.get(f'http://{host}:5000/{game}')
            resp.raise_for_status()
            print(f"received {resp}")
        except Exception as e:
            print (f"http error {e}")

        # Simulate some CPU work
        for _ in range(10**7):
            _ = random.random() * random.random()

        time.sleep(random.uniform(0.2, 0.4))


Directory: lib
  File: gaming_server.py
  Content:
import os
import pyroscope
from flask import Flask
from arcade.arcade import order_arcade
from puzzle.puzzle import order_puzzle
from shooter.shooter import order_shooter

app_name = os.getenv("PYROSCOPE_APPLICATION_NAME", "flask-gaming-app")
server_address = os.getenv("PYROSCOPE_SERVER_ADDRESS", "http://pyroscope:4040")
basic_auth_username = os.getenv("PYROSCOPE_BASIC_AUTH_USER", "")
basic_auth_password = os.getenv("PYROSCOPE_BASIC_AUTH_PASSWORD", "")
port = int(os.getenv("GAMING_LISTEN_PORT", "5000"))

pyroscope.configure(
    application_name=app_name,
    server_address=server_address,
    basic_auth_username=basic_auth_username,
    basic_auth_password=basic_auth_password,
    tags={"region": f'{os.getenv("REGION")}'}
)

app = Flask(__name__)

@app.route("/arcade")
def arcade():
    order_arcade(0.2)
    return "<p>Arcade game requested</p>"

@app.route("/shooter")
def shooter():
    order_shooter(0.3)
    return "<p>Shooter game requested</p>"

@app.route("/puzzle")
def puzzle():
    order_puzzle(0.4)
    return "<p>Puzzle game requested</p>"

@app.route("/")
def environment():
    result = "<h1>Environment Variables:</h1>"
    for key, value in os.environ.items():
        result += f"<p>{key}={value}</p>"
    return result

if __name__ == "__main__":
    app.run(threaded=False, processes=1, host='0.0.0.0', port=port, debug=False)


Directory: lib/arcade
  File: arcade.py
  Content:
from utility.utility import find_nearest_game, simulate_physics

def order_arcade(search_radius):
    simulate_physics(search_radius, "arcade")
    find_nearest_game(search_radius, "arcade")


Directory: lib/puzzle
  File: puzzle.py
  Content:
from utility.utility import find_nearest_game, solve_puzzle

def order_puzzle(search_radius):
    solve_puzzle()
    find_nearest_game(search_radius, "puzzle")


Directory: lib/shooter
  File: shooter.py
  Content:
from utility.utility import find_nearest_game, calculate_path

def order_shooter(search_radius):
    calculate_path("enemy", "target")
    find_nearest_game(search_radius, "shooter")


Directory: lib/utility
  File: utility.py
  Content:
import pyroscope
import random
import time

def find_nearest_game(search_radius, game):
    with pyroscope.tag_wrapper({"game": game}):
        for _ in range(int(search_radius * 10**6)):
            _ = random.random() * random.random()

def simulate_physics(time_step, game):
    with pyroscope.tag_wrapper({"game": game, "task": "physics_simulation"}):
        for _ in range(int(time_step * 10**6)):
            _ = random.random() * random.random()

def solve_puzzle():
    with pyroscope.tag_wrapper({"task": "solve_puzzle"}):
        for _ in range(10**7):
            _ = random.random() * random.random()

def calculate_path(start, goal):
    with pyroscope.tag_wrapper({"task": "ai_pathfinding"}):
        for _ in range(10**7):
            _ = random.random() * random.random()


