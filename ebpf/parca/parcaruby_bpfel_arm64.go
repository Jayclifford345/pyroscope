// Code generated by bpf2go; DO NOT EDIT.
//go:build arm64

package parca

import (
	"bytes"
	_ "embed"
	"fmt"
	"io"

	"github.com/cilium/ebpf"
)

type ParcaRubyProcessData struct {
	RbFrameAddr uint64
	RbVersion   uint32
	_           [4]byte
	StartTime   uint64
}

type ParcaRubyRubyVersionOffsets struct {
	MajorVersion         int32
	MinorVersion         int32
	PatchVersion         int32
	VmOffset             int32
	VmSizeOffset         int32
	ControlFrameT_sizeof int32
	CfpOffset            int32
	LabelOffset          int32
	PathFlavour          int32
	LineInfoSizeOffset   int32
	LineInfoTableOffset  int32
	LinenoOffset         int32
	MainThreadOffset     int32
	EcOffset             int32
}

type ParcaRubySampleState struct {
	Stack struct {
		Timestamp    uint64
		Frames       ParcaRubyStackTraceT
		Pid          uint32
		Cpu          uint32
		SyscallId    int32
		_            [4]byte
		ExpectedSize int64
		Comm         [25]int8
		_            [3]byte
		StackStatus  uint32
	}
	BaseStack             uint64
	Cfp                   uint64
	RubyStackProgramCount int32
	RbVersion             int32
}

type ParcaRubyStackCountKeyT struct {
	Pid                int32
	Tgid               int32
	UserStackId        uint64
	KernelStackId      uint64
	InterpreterStackId uint64
}

type ParcaRubyStackTraceT struct {
	Len       uint64
	Addresses [127]uint64
}

type ParcaRubySymbolT struct {
	ClassName  [32]int8
	MethodName [64]int8
	Path       [128]int8
}

type ParcaRubyUnwindStateT struct {
	Ip              uint64
	Sp              uint64
	Bp              uint64
	TailCalls       uint32
	_               [4]byte
	Stack           ParcaRubyStackTraceT
	UnwindingJit    bool
	UseFp           bool
	_               [6]byte
	InterpreterType uint64
	StackKey        ParcaRubyStackCountKeyT
}

// LoadParcaRuby returns the embedded CollectionSpec for ParcaRuby.
func LoadParcaRuby() (*ebpf.CollectionSpec, error) {
	reader := bytes.NewReader(_ParcaRubyBytes)
	spec, err := ebpf.LoadCollectionSpecFromReader(reader)
	if err != nil {
		return nil, fmt.Errorf("can't load ParcaRuby: %w", err)
	}

	return spec, err
}

// LoadParcaRubyObjects loads ParcaRuby and converts it into a struct.
//
// The following types are suitable as obj argument:
//
//	*ParcaRubyObjects
//	*ParcaRubyPrograms
//	*ParcaRubyMaps
//
// See ebpf.CollectionSpec.LoadAndAssign documentation for details.
func LoadParcaRubyObjects(obj interface{}, opts *ebpf.CollectionOptions) error {
	spec, err := LoadParcaRuby()
	if err != nil {
		return err
	}

	return spec.LoadAndAssign(obj, opts)
}

// ParcaRubySpecs contains maps and programs before they are loaded into the kernel.
//
// It can be passed ebpf.CollectionSpec.Assign.
type ParcaRubySpecs struct {
	ParcaRubyProgramSpecs
	ParcaRubyMapSpecs
}

// ParcaRubySpecs contains programs before they are loaded into the kernel.
//
// It can be passed ebpf.CollectionSpec.Assign.
type ParcaRubyProgramSpecs struct {
	UnwindRubyStack *ebpf.ProgramSpec `ebpf:"unwind_ruby_stack"`
	WalkRubyStack   *ebpf.ProgramSpec `ebpf:"walk_ruby_stack"`
}

// ParcaRubyMapSpecs contains maps before they are loaded into the kernel.
//
// It can be passed ebpf.CollectionSpec.Assign.
type ParcaRubyMapSpecs struct {
	GlobalState            *ebpf.MapSpec `ebpf:"global_state"`
	Heap                   *ebpf.MapSpec `ebpf:"heap"`
	PidToRbThread          *ebpf.MapSpec `ebpf:"pid_to_rb_thread"`
	Programs               *ebpf.MapSpec `ebpf:"programs"`
	StackCounts            *ebpf.MapSpec `ebpf:"stack_counts"`
	StackTraces            *ebpf.MapSpec `ebpf:"stack_traces"`
	SymbolIndexStorage     *ebpf.MapSpec `ebpf:"symbol_index_storage"`
	SymbolTable            *ebpf.MapSpec `ebpf:"symbol_table"`
	VersionSpecificOffsets *ebpf.MapSpec `ebpf:"version_specific_offsets"`
}

// ParcaRubyObjects contains all objects after they have been loaded into the kernel.
//
// It can be passed to LoadParcaRubyObjects or ebpf.CollectionSpec.LoadAndAssign.
type ParcaRubyObjects struct {
	ParcaRubyPrograms
	ParcaRubyMaps
}

func (o *ParcaRubyObjects) Close() error {
	return _ParcaRubyClose(
		&o.ParcaRubyPrograms,
		&o.ParcaRubyMaps,
	)
}

// ParcaRubyMaps contains all maps after they have been loaded into the kernel.
//
// It can be passed to LoadParcaRubyObjects or ebpf.CollectionSpec.LoadAndAssign.
type ParcaRubyMaps struct {
	GlobalState            *ebpf.Map `ebpf:"global_state"`
	Heap                   *ebpf.Map `ebpf:"heap"`
	PidToRbThread          *ebpf.Map `ebpf:"pid_to_rb_thread"`
	Programs               *ebpf.Map `ebpf:"programs"`
	StackCounts            *ebpf.Map `ebpf:"stack_counts"`
	StackTraces            *ebpf.Map `ebpf:"stack_traces"`
	SymbolIndexStorage     *ebpf.Map `ebpf:"symbol_index_storage"`
	SymbolTable            *ebpf.Map `ebpf:"symbol_table"`
	VersionSpecificOffsets *ebpf.Map `ebpf:"version_specific_offsets"`
}

func (m *ParcaRubyMaps) Close() error {
	return _ParcaRubyClose(
		m.GlobalState,
		m.Heap,
		m.PidToRbThread,
		m.Programs,
		m.StackCounts,
		m.StackTraces,
		m.SymbolIndexStorage,
		m.SymbolTable,
		m.VersionSpecificOffsets,
	)
}

// ParcaRubyPrograms contains all programs after they have been loaded into the kernel.
//
// It can be passed to LoadParcaRubyObjects or ebpf.CollectionSpec.LoadAndAssign.
type ParcaRubyPrograms struct {
	UnwindRubyStack *ebpf.Program `ebpf:"unwind_ruby_stack"`
	WalkRubyStack   *ebpf.Program `ebpf:"walk_ruby_stack"`
}

func (p *ParcaRubyPrograms) Close() error {
	return _ParcaRubyClose(
		p.UnwindRubyStack,
		p.WalkRubyStack,
	)
}

func _ParcaRubyClose(closers ...io.Closer) error {
	for _, closer := range closers {
		if err := closer.Close(); err != nil {
			return err
		}
	}
	return nil
}

// Do not access this directly.
//
//go:embed parcaruby_bpfel_arm64.o
var _ParcaRubyBytes []byte
